// **********************************************************************
//
// Copyright (c) 2003-2010 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

// Ice version 3.4.1

// <auto-generated>
//
// Generated from file `TradeGateway.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

#include <TradeGateway.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 304
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

static const ::std::string __TradeGateway__SessionReceiver__onExecutionReport_name = "onExecutionReport";

static const ::std::string __TradeGateway__SessionReceiver__onMessage_name = "onMessage";

static const ::std::string __TradeGateway__TradeApiSession__registerCallback_name = "registerCallback";

static const ::std::string __TradeGateway__TradeApiSession__unregisterCallback_name = "unregisterCallback";

static const ::std::string __TradeGateway__TradeApiSession__startSession_name = "startSession";

static const ::std::string __TradeGateway__TradeApiSession__stopSession_name = "stopSession";

static const ::std::string __TradeGateway__TradeApiSession__login_name = "login";

static const ::std::string __TradeGateway__TradeApiSession__logout_name = "logout";

static const ::std::string __TradeGateway__TradeApiSession__NewOrderSingle_name = "NewOrderSingle";

static const ::std::string __TradeGateway__TradeApiSession__cancelOrderSingle_name = "cancelOrderSingle";

static const ::std::string __TradeGateway__TradeApiSession__NewOrders_name = "NewOrders";

static const ::std::string __TradeGateway__TradeApiSession__cancelOrders_name = "cancelOrders";

static const ::std::string __TradeGateway__TradeApiSession__QryOrder_name = "QryOrder";

static const ::std::string __TradeGateway__TradeApiSession__QryTrade_name = "QryTrade";

static const ::std::string __TradeGateway__TradeApiSession__QryAsset_name = "QryAsset";

static const ::std::string __TradeGateway__TradeApiSession__QryPosition_name = "QryPosition";

static const ::std::string __TradeGateway__TradeApiSession__destroy_name = "destroy";

static const ::std::string __TradeGateway__SessionManager__createSession_name = "createSession";

static const ::std::string __TradeGateway__SessionManager__freeSession_name = "freeSession";

::Ice::Object* IceInternal::upCast(::TradeGateway::SessionReceiver* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::TradeGateway::SessionReceiver* p) { return p; }

::Ice::Object* IceInternal::upCast(::TradeGateway::TradeApiSession* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::TradeGateway::TradeApiSession* p) { return p; }

::Ice::Object* IceInternal::upCast(::TradeGateway::SessionManager* p) { return p; }
::IceProxy::Ice::Object* IceInternal::upCast(::IceProxy::TradeGateway::SessionManager* p) { return p; }

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::SessionReceiverPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::TradeGateway::SessionReceiver;
        v->__copyFrom(proxy);
    }
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::TradeApiSessionPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::TradeGateway::TradeApiSession;
        v->__copyFrom(proxy);
    }
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::SessionManagerPrx& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::TradeGateway::SessionManager;
        v->__copyFrom(proxy);
    }
}

TradeGateway::OperationFailedException::OperationFailedException(const ::std::string& __ice_reason) :
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    UserException(),
#else
    ::Ice::UserException(),
#endif
    reason(__ice_reason)
{
}

TradeGateway::OperationFailedException::~OperationFailedException() throw()
{
}

static const char* __TradeGateway__OperationFailedException_name = "TradeGateway::OperationFailedException";

::std::string
TradeGateway::OperationFailedException::ice_name() const
{
    return __TradeGateway__OperationFailedException_name;
}

::Ice::Exception*
TradeGateway::OperationFailedException::ice_clone() const
{
    return new OperationFailedException(*this);
}

void
TradeGateway::OperationFailedException::ice_throw() const
{
    throw *this;
}

void
TradeGateway::OperationFailedException::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(::std::string("::TradeGateway::OperationFailedException"), false);
    __os->startWriteSlice();
    __os->write(reason);
    __os->endWriteSlice();
}

void
TradeGateway::OperationFailedException::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->read(myId, false);
    }
    __is->startReadSlice();
    __is->read(reason);
    __is->endReadSlice();
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
TradeGateway::OperationFailedException::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception TradeGateway::OperationFailedException was not generated with stream support";
    throw ex;
}

void
TradeGateway::OperationFailedException::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "exception TradeGateway::OperationFailedException was not generated with stream support";
    throw ex;
}
#endif

struct __F__TradeGateway__OperationFailedException : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow()
    {
        throw ::TradeGateway::OperationFailedException();
    }
};

static ::IceInternal::UserExceptionFactoryPtr __F__TradeGateway__OperationFailedException__Ptr = new __F__TradeGateway__OperationFailedException;

const ::IceInternal::UserExceptionFactoryPtr&
TradeGateway::OperationFailedException::ice_factory()
{
    return __F__TradeGateway__OperationFailedException__Ptr;
}

class __F__TradeGateway__OperationFailedException__Init
{
public:

    __F__TradeGateway__OperationFailedException__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::TradeGateway::OperationFailedException", ::TradeGateway::OperationFailedException::ice_factory());
    }

    ~__F__TradeGateway__OperationFailedException__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::TradeGateway::OperationFailedException");
    }
};

static __F__TradeGateway__OperationFailedException__Init __F__TradeGateway__OperationFailedException__i;

#ifdef __APPLE__
extern "C" { void __F__TradeGateway__OperationFailedException__initializer() {} }
#endif

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::MessageType v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 3);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::MessageType& v)
{
    ::Ice::Byte val;
    __is->read(val, 3);
    v = static_cast< ::TradeGateway::MessageType>(val);
}

void
TradeGateway::MessageInfo::__write(::IceInternal::BasicStream* __os) const
{
    ::TradeGateway::__write(__os, type);
    __os->write(name);
    __os->write(value);
}

void
TradeGateway::MessageInfo::__read(::IceInternal::BasicStream* __is)
{
    ::TradeGateway::__read(__is, type);
    __is->read(name);
    __is->read(value);
}

void
TradeGateway::__writeMessageInfoSeq(::IceInternal::BasicStream* __os, const ::TradeGateway::MessageInfo* begin, const ::TradeGateway::MessageInfo* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
TradeGateway::__readMessageInfoSeq(::IceInternal::BasicStream* __is, ::TradeGateway::MessageInfoSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(3, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
TradeGateway::AssetInfo::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(accountId);
    __os->write(initial);
    __os->write(balance);
    __os->write(equity);
    __os->write(available);
    __os->write(frozenMargin);
    ::Ice::__writePropertyDict(__os, extra);
}

void
TradeGateway::AssetInfo::__read(::IceInternal::BasicStream* __is)
{
    __is->read(accountId);
    __is->read(initial);
    __is->read(balance);
    __is->read(equity);
    __is->read(available);
    __is->read(frozenMargin);
    ::Ice::__readPropertyDict(__is, extra);
}

void
TradeGateway::__writeAssetInfoSeq(::IceInternal::BasicStream* __os, const ::TradeGateway::AssetInfo* begin, const ::TradeGateway::AssetInfo* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
TradeGateway::__readAssetInfoSeq(::IceInternal::BasicStream* __is, ::TradeGateway::AssetInfoSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(42, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::MarketIdSource v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 8);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::MarketIdSource& v)
{
    ::Ice::Byte val;
    __is->read(val, 8);
    v = static_cast< ::TradeGateway::MarketIdSource>(val);
}

void
TradeGateway::InstrumentId::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(securityID);
    ::TradeGateway::__write(__os, securityIDSource);
}

void
TradeGateway::InstrumentId::__read(::IceInternal::BasicStream* __is)
{
    __is->read(securityID);
    ::TradeGateway::__read(__is, securityIDSource);
}

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::Side v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 7);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::Side& v)
{
    ::Ice::Byte val;
    __is->read(val, 7);
    v = static_cast< ::TradeGateway::Side>(val);
}

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::PositionEffect v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 4);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::PositionEffect& v)
{
    ::Ice::Byte val;
    __is->read(val, 4);
    v = static_cast< ::TradeGateway::PositionEffect>(val);
}

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::OrdType v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 4);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::OrdType& v)
{
    ::Ice::Byte val;
    __is->read(val, 4);
    v = static_cast< ::TradeGateway::OrdType>(val);
}

void
TradeGateway::Order::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(accountId);
    inst.__write(__os);
    ::TradeGateway::__write(__os, s);
    ::TradeGateway::__write(__os, posEfct);
    ::TradeGateway::__write(__os, type);
    __os->write(lmtPrice);
    __os->write(ordQty);
    __os->write(ordId);
    __os->write(date);
    __os->write(time);
    ::Ice::__writePropertyDict(__os, extra);
}

void
TradeGateway::Order::__read(::IceInternal::BasicStream* __is)
{
    __is->read(accountId);
    inst.__read(__is);
    ::TradeGateway::__read(__is, s);
    ::TradeGateway::__read(__is, posEfct);
    ::TradeGateway::__read(__is, type);
    __is->read(lmtPrice);
    __is->read(ordQty);
    __is->read(ordId);
    __is->read(date);
    __is->read(time);
    ::Ice::__readPropertyDict(__is, extra);
}

void
TradeGateway::__writeOrderSeq(::IceInternal::BasicStream* __os, const ::TradeGateway::Order* begin, const ::TradeGateway::Order* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
TradeGateway::__readOrderSeq(::IceInternal::BasicStream* __is, ::TradeGateway::OrderSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(28, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::OrderStatus v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 10);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::OrderStatus& v)
{
    ::Ice::Byte val;
    __is->read(val, 10);
    v = static_cast< ::TradeGateway::OrderStatus>(val);
}

void
TradeGateway::OrderReport::__write(::IceInternal::BasicStream* __os) const
{
    base.__write(__os);
    ::TradeGateway::__write(__os, ordStatus);
    __os->write(cumQty);
    __os->write(avgPx);
    __os->write(leavesQty);
    __os->write(text);
    __os->write(seq);
    ::Ice::__writePropertyDict(__os, extra);
}

void
TradeGateway::OrderReport::__read(::IceInternal::BasicStream* __is)
{
    base.__read(__is);
    ::TradeGateway::__read(__is, ordStatus);
    __is->read(cumQty);
    __is->read(avgPx);
    __is->read(leavesQty);
    __is->read(text);
    __is->read(seq);
    ::Ice::__readPropertyDict(__is, extra);
}

void
TradeGateway::__writeOrderReportSeq(::IceInternal::BasicStream* __os, const ::TradeGateway::OrderReport* begin, const ::TradeGateway::OrderReport* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
TradeGateway::__readOrderReportSeq(::IceInternal::BasicStream* __is, ::TradeGateway::OrderReportSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(48, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::ExecType v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 5);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::ExecType& v)
{
    ::Ice::Byte val;
    __is->read(val, 5);
    v = static_cast< ::TradeGateway::ExecType>(val);
}

void
TradeGateway::ExecutionReport::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(accountId);
    __os->write(ordId);
    __os->write(execId);
    ::TradeGateway::__write(__os, type);
    __os->write(ordRejReason);
    __os->write(lastQty);
    __os->write(lastPx);
    __os->write(tradeDate);
    __os->write(transactTime);
    __os->write(seq);
    ::Ice::__writePropertyDict(__os, extra);
}

void
TradeGateway::ExecutionReport::__read(::IceInternal::BasicStream* __is)
{
    __is->read(accountId);
    __is->read(ordId);
    __is->read(execId);
    ::TradeGateway::__read(__is, type);
    __is->read(ordRejReason);
    __is->read(lastQty);
    __is->read(lastPx);
    __is->read(tradeDate);
    __is->read(transactTime);
    __is->read(seq);
    ::Ice::__readPropertyDict(__is, extra);
}

void
TradeGateway::__writeExecutionReportSeq(::IceInternal::BasicStream* __os, const ::TradeGateway::ExecutionReport* begin, const ::TradeGateway::ExecutionReport* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
TradeGateway::__readExecutionReportSeq(::IceInternal::BasicStream* __is, ::TradeGateway::ExecutionReportSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(31, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::PositionDirection v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 3);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::PositionDirection& v)
{
    ::Ice::Byte val;
    __is->read(val, 3);
    v = static_cast< ::TradeGateway::PositionDirection>(val);
}

void
TradeGateway::VolumePrice::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(volume);
    __os->write(frozenVolume);
    __os->write(price);
}

void
TradeGateway::VolumePrice::__read(::IceInternal::BasicStream* __is)
{
    __is->read(volume);
    __is->read(frozenVolume);
    __is->read(price);
}

void
TradeGateway::PositionInfo::__write(::IceInternal::BasicStream* __os) const
{
    __os->write(accountId);
    inst.__write(__os);
    ::TradeGateway::__write(__os, direction);
    previous.__write(__os);
    today.__write(__os);
    forETF.__write(__os);
    __os->write(margin);
    __os->write(currPrice);
    ::Ice::__writePropertyDict(__os, extra);
}

void
TradeGateway::PositionInfo::__read(::IceInternal::BasicStream* __is)
{
    __is->read(accountId);
    inst.__read(__is);
    ::TradeGateway::__read(__is, direction);
    previous.__read(__is);
    today.__read(__is);
    forETF.__read(__is);
    __is->read(margin);
    __is->read(currPrice);
    ::Ice::__readPropertyDict(__is, extra);
}

void
TradeGateway::__writePositionInfoSeq(::IceInternal::BasicStream* __os, const ::TradeGateway::PositionInfo* begin, const ::TradeGateway::PositionInfo* end)
{
    ::Ice::Int size = static_cast< ::Ice::Int>(end - begin);
    __os->writeSize(size);
    for(int i = 0; i < size; ++i)
    {
        begin[i].__write(__os);
    }
}

void
TradeGateway::__readPositionInfoSeq(::IceInternal::BasicStream* __is, ::TradeGateway::PositionInfoSeq& v)
{
    ::Ice::Int sz;
    __is->readAndCheckSeqSize(93, sz);
    v.resize(sz);
    for(int i = 0; i < sz; ++i)
    {
        v[i].__read(__is);
    }
}

void
TradeGateway::__write(::IceInternal::BasicStream* __os, ::TradeGateway::ResumeType v)
{
    __os->write(static_cast< ::Ice::Byte>(v), 3);
}

void
TradeGateway::__read(::IceInternal::BasicStream* __is, ::TradeGateway::ResumeType& v)
{
    ::Ice::Byte val;
    __is->read(val, 3);
    v = static_cast< ::TradeGateway::ResumeType>(val);
}

void
IceProxy::TradeGateway::SessionReceiver::onExecutionReport(const ::TradeGateway::ExecutionReportSeq& report, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::SessionReceiver* __del = dynamic_cast< ::IceDelegate::TradeGateway::SessionReceiver*>(__delBase.get());
            __del->onExecutionReport(report, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::SessionReceiver::begin_onExecutionReport(const ::TradeGateway::ExecutionReportSeq& report, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__SessionReceiver__onExecutionReport_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__SessionReceiver__onExecutionReport_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(report.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeExecutionReportSeq(__os, &report[0], &report[0] + report.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::SessionReceiver::end_onExecutionReport(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __TradeGateway__SessionReceiver__onExecutionReport_name);
}

bool
IceProxy::TradeGateway::SessionReceiver::onExecutionReport_async(const ::TradeGateway::AMI_SessionReceiver_onExecutionReportPtr& __cb, const ::TradeGateway::ExecutionReportSeq& report)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::TradeGateway::newCallback_SessionReceiver_onExecutionReport(__cb, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__response, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__exception, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__sent);
    }
    else
    {
         __del = ::TradeGateway::newCallback_SessionReceiver_onExecutionReport(__cb, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__response, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_onExecutionReport(report, 0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::TradeGateway::SessionReceiver::onExecutionReport_async(const ::TradeGateway::AMI_SessionReceiver_onExecutionReportPtr& __cb, const ::TradeGateway::ExecutionReportSeq& report, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::TradeGateway::newCallback_SessionReceiver_onExecutionReport(__cb, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__response, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__exception, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__sent);
    }
    else
    {
         __del = ::TradeGateway::newCallback_SessionReceiver_onExecutionReport(__cb, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__response, &::TradeGateway::AMI_SessionReceiver_onExecutionReport::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_onExecutionReport(report, &__ctx, __del);
    return __ar->sentSynchronously();
}

void
IceProxy::TradeGateway::SessionReceiver::onMessage(const ::TradeGateway::MessageInfoSeq& msg, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::SessionReceiver* __del = dynamic_cast< ::IceDelegate::TradeGateway::SessionReceiver*>(__delBase.get());
            __del->onMessage(msg, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::SessionReceiver::begin_onMessage(const ::TradeGateway::MessageInfoSeq& msg, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__SessionReceiver__onMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__SessionReceiver__onMessage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(msg.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeMessageInfoSeq(__os, &msg[0], &msg[0] + msg.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::SessionReceiver::end_onMessage(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __TradeGateway__SessionReceiver__onMessage_name);
}

bool
IceProxy::TradeGateway::SessionReceiver::onMessage_async(const ::TradeGateway::AMI_SessionReceiver_onMessagePtr& __cb, const ::TradeGateway::MessageInfoSeq& msg)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::TradeGateway::newCallback_SessionReceiver_onMessage(__cb, &::TradeGateway::AMI_SessionReceiver_onMessage::__response, &::TradeGateway::AMI_SessionReceiver_onMessage::__exception, &::TradeGateway::AMI_SessionReceiver_onMessage::__sent);
    }
    else
    {
         __del = ::TradeGateway::newCallback_SessionReceiver_onMessage(__cb, &::TradeGateway::AMI_SessionReceiver_onMessage::__response, &::TradeGateway::AMI_SessionReceiver_onMessage::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_onMessage(msg, 0, __del);
    return __ar->sentSynchronously();
}

bool
IceProxy::TradeGateway::SessionReceiver::onMessage_async(const ::TradeGateway::AMI_SessionReceiver_onMessagePtr& __cb, const ::TradeGateway::MessageInfoSeq& msg, const ::Ice::Context& __ctx)
{
    ::IceInternal::CallbackBasePtr __del;
    if(dynamic_cast< ::Ice::AMISentCallback*>(__cb.get()))
    {
         __del = ::TradeGateway::newCallback_SessionReceiver_onMessage(__cb, &::TradeGateway::AMI_SessionReceiver_onMessage::__response, &::TradeGateway::AMI_SessionReceiver_onMessage::__exception, &::TradeGateway::AMI_SessionReceiver_onMessage::__sent);
    }
    else
    {
         __del = ::TradeGateway::newCallback_SessionReceiver_onMessage(__cb, &::TradeGateway::AMI_SessionReceiver_onMessage::__response, &::TradeGateway::AMI_SessionReceiver_onMessage::__exception);
    }
    ::Ice::AsyncResultPtr __ar = begin_onMessage(msg, &__ctx, __del);
    return __ar->sentSynchronously();
}

const ::std::string&
IceProxy::TradeGateway::SessionReceiver::ice_staticId()
{
    return ::TradeGateway::SessionReceiver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::TradeGateway::SessionReceiver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::TradeGateway::SessionReceiver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::TradeGateway::SessionReceiver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::TradeGateway::SessionReceiver);
}

::IceProxy::Ice::Object*
IceProxy::TradeGateway::SessionReceiver::__newInstance() const
{
    return new SessionReceiver;
}

void
IceProxy::TradeGateway::TradeApiSession::registerCallback(const ::TradeGateway::SessionReceiverPrx& proxy, ::TradeGateway::ResumeType type, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__registerCallback_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->registerCallback(proxy, type, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_registerCallback(const ::TradeGateway::SessionReceiverPrx& proxy, ::TradeGateway::ResumeType type, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__registerCallback_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__registerCallback_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__registerCallback_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(proxy.get())));
        ::TradeGateway::__write(__os, type);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_registerCallback(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__registerCallback_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::TradeGateway::TradeApiSession::unregisterCallback(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->unregisterCallback(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_unregisterCallback(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__unregisterCallback_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__unregisterCallback_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_unregisterCallback(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __TradeGateway__TradeApiSession__unregisterCallback_name);
}

void
IceProxy::TradeGateway::TradeApiSession::startSession(const ::std::string& frontAddress, const ::Ice::PropertyDict& params, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__startSession_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->startSession(frontAddress, params, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_startSession(const ::std::string& frontAddress, const ::Ice::PropertyDict& params, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__startSession_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__startSession_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__startSession_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(frontAddress);
        ::Ice::__writePropertyDict(__os, params);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_startSession(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__startSession_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::TradeGateway::TradeApiSession::stopSession(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__stopSession_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->stopSession(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_stopSession(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__stopSession_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__stopSession_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__stopSession_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_stopSession(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__stopSession_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::TradeGateway::TradeApiSession::login(const ::std::string& accName, const ::std::string& accPassword, const ::Ice::PropertyDict& params, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__login_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->login(accName, accPassword, params, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_login(const ::std::string& accName, const ::std::string& accPassword, const ::Ice::PropertyDict& params, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__login_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__login_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__login_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(accName);
        __os->write(accPassword);
        ::Ice::__writePropertyDict(__os, params);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_login(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__login_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

void
IceProxy::TradeGateway::TradeApiSession::logout(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__logout_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->logout(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_logout(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__logout_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__logout_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__logout_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_logout(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__logout_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

::std::string
IceProxy::TradeGateway::TradeApiSession::NewOrderSingle(const ::TradeGateway::Order& ord, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__NewOrderSingle_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            return __del->NewOrderSingle(ord, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_NewOrderSingle(const ::TradeGateway::Order& ord, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__NewOrderSingle_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__NewOrderSingle_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__NewOrderSingle_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        ord.__write(__os);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::TradeGateway::TradeApiSession::end_NewOrderSingle(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__NewOrderSingle_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::TradeGateway::TradeApiSession::cancelOrderSingle(const ::std::string& orderId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__cancelOrderSingle_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->cancelOrderSingle(orderId, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_cancelOrderSingle(const ::std::string& orderId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__cancelOrderSingle_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__cancelOrderSingle_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__cancelOrderSingle_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(orderId);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_cancelOrderSingle(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__cancelOrderSingle_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

::Ice::StringSeq
IceProxy::TradeGateway::TradeApiSession::NewOrders(const ::TradeGateway::OrderSeq& ords, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__NewOrders_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            return __del->NewOrders(ords, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_NewOrders(const ::TradeGateway::OrderSeq& ords, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__NewOrders_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__NewOrders_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__NewOrders_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(ords.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeOrderSeq(__os, &ords[0], &ords[0] + ords.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::StringSeq
IceProxy::TradeGateway::TradeApiSession::end_NewOrders(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__NewOrders_name);
    ::Ice::StringSeq __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    __is->read(__ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::TradeGateway::TradeApiSession::cancelOrders(const ::Ice::StringSeq& orderId, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__cancelOrders_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->cancelOrders(orderId, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_cancelOrders(const ::Ice::StringSeq& orderId, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__cancelOrders_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__cancelOrders_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__cancelOrders_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        if(orderId.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&orderId[0], &orderId[0] + orderId.size());
        }
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_cancelOrders(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__cancelOrders_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->skipEmptyEncaps();
}

::TradeGateway::OrderReportSeq
IceProxy::TradeGateway::TradeApiSession::QryOrder(const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__QryOrder_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            return __del->QryOrder(ordid, positionString, maxReturn, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_QryOrder(const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__QryOrder_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__QryOrder_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__QryOrder_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(ordid);
        __os->write(positionString);
        __os->write(maxReturn);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::TradeGateway::OrderReportSeq
IceProxy::TradeGateway::TradeApiSession::end_QryOrder(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__QryOrder_name);
    ::TradeGateway::OrderReportSeq __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::TradeGateway::__readOrderReportSeq(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::TradeGateway::ExecutionReportSeq
IceProxy::TradeGateway::TradeApiSession::QryTrade(const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__QryTrade_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            return __del->QryTrade(ordid, positionString, maxReturn, __ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_QryTrade(const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__QryTrade_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__QryTrade_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__QryTrade_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(ordid);
        __os->write(positionString);
        __os->write(maxReturn);
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::TradeGateway::ExecutionReportSeq
IceProxy::TradeGateway::TradeApiSession::end_QryTrade(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__QryTrade_name);
    ::TradeGateway::ExecutionReportSeq __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::TradeGateway::__readExecutionReportSeq(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::TradeGateway::AssetInfoSeq
IceProxy::TradeGateway::TradeApiSession::QryAsset(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__QryAsset_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            return __del->QryAsset(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_QryAsset(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__QryAsset_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__QryAsset_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__QryAsset_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::TradeGateway::AssetInfoSeq
IceProxy::TradeGateway::TradeApiSession::end_QryAsset(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__QryAsset_name);
    ::TradeGateway::AssetInfoSeq __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::TradeGateway::__readAssetInfoSeq(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

::TradeGateway::PositionInfoSeq
IceProxy::TradeGateway::TradeApiSession::QryPosition(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__TradeApiSession__QryPosition_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            return __del->QryPosition(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_QryPosition(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__TradeApiSession__QryPosition_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__QryPosition_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__QryPosition_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::TradeGateway::PositionInfoSeq
IceProxy::TradeGateway::TradeApiSession::end_QryPosition(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__TradeApiSession__QryPosition_name);
    ::TradeGateway::PositionInfoSeq __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::TradeGateway::__readPositionInfoSeq(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::TradeGateway::TradeApiSession::destroy(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::TradeApiSession* __del = dynamic_cast< ::IceDelegate::TradeGateway::TradeApiSession*>(__delBase.get());
            __del->destroy(__ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::TradeApiSession::begin_destroy(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__TradeApiSession__destroy_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__TradeApiSession__destroy_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::TradeApiSession::end_destroy(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __TradeGateway__TradeApiSession__destroy_name);
}

const ::std::string&
IceProxy::TradeGateway::TradeApiSession::ice_staticId()
{
    return ::TradeGateway::TradeApiSession::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::TradeGateway::TradeApiSession::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::TradeGateway::TradeApiSession);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::TradeGateway::TradeApiSession::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::TradeGateway::TradeApiSession);
}

::IceProxy::Ice::Object*
IceProxy::TradeGateway::TradeApiSession::__newInstance() const
{
    return new TradeApiSession;
}

::TradeGateway::TradeApiSessionPrx
IceProxy::TradeGateway::SessionManager::createSession(const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__TradeGateway__SessionManager__createSession_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::SessionManager* __del = dynamic_cast< ::IceDelegate::TradeGateway::SessionManager*>(__delBase.get());
            return __del->createSession(__ctx);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::SessionManager::begin_createSession(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__TradeGateway__SessionManager__createSession_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__SessionManager__createSession_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__SessionManager__createSession_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::TradeGateway::TradeApiSessionPrx
IceProxy::TradeGateway::SessionManager::end_createSession(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __TradeGateway__SessionManager__createSession_name);
    ::TradeGateway::TradeApiSessionPrx __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::TradeGateway::OperationFailedException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__getIs();
    __is->startReadEncaps();
    ::TradeGateway::__read(__is, __ret);
    __is->endReadEncaps();
    return __ret;
}

void
IceProxy::TradeGateway::SessionManager::freeSession(const ::TradeGateway::TradeApiSessionPrx& oldSession, const ::Ice::Context* __ctx)
{
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::TradeGateway::SessionManager* __del = dynamic_cast< ::IceDelegate::TradeGateway::SessionManager*>(__delBase.get());
            __del->freeSession(oldSession, __ctx);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::TradeGateway::SessionManager::begin_freeSession(const ::TradeGateway::TradeApiSessionPrx& oldSession, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __TradeGateway__SessionManager__freeSession_name, __del, __cookie);
    try
    {
        __result->__prepare(__TradeGateway__SessionManager__freeSession_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__getOs();
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(oldSession.get())));
        __os->endWriteEncaps();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::TradeGateway::SessionManager::end_freeSession(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __TradeGateway__SessionManager__freeSession_name);
}

const ::std::string&
IceProxy::TradeGateway::SessionManager::ice_staticId()
{
    return ::TradeGateway::SessionManager::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::TradeGateway::SessionManager::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::TradeGateway::SessionManager);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::TradeGateway::SessionManager::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::TradeGateway::SessionManager);
}

::IceProxy::Ice::Object*
IceProxy::TradeGateway::SessionManager::__newInstance() const
{
    return new SessionManager;
}

void
IceDelegateM::TradeGateway::SessionReceiver::onExecutionReport(const ::TradeGateway::ExecutionReportSeq& report, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__SessionReceiver__onExecutionReport_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(report.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeExecutionReportSeq(__os, &report[0], &report[0] + report.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::TradeGateway::SessionReceiver::onMessage(const ::TradeGateway::MessageInfoSeq& msg, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__SessionReceiver__onMessage_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(msg.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeMessageInfoSeq(__os, &msg[0], &msg[0] + msg.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::registerCallback(const ::TradeGateway::SessionReceiverPrx& proxy, ::TradeGateway::ResumeType type, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__registerCallback_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(proxy.get())));
        ::TradeGateway::__write(__os, type);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::unregisterCallback(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__unregisterCallback_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::startSession(const ::std::string& frontAddress, const ::Ice::PropertyDict& params, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__startSession_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(frontAddress);
        ::Ice::__writePropertyDict(__os, params);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::stopSession(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__stopSession_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::login(const ::std::string& accName, const ::std::string& accPassword, const ::Ice::PropertyDict& params, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__login_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(accName);
        __os->write(accPassword);
        ::Ice::__writePropertyDict(__os, params);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::logout(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__logout_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::TradeGateway::TradeApiSession::NewOrderSingle(const ::TradeGateway::Order& ord, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__NewOrderSingle_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        ord.__write(__os);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::cancelOrderSingle(const ::std::string& orderId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__cancelOrderSingle_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(orderId);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::StringSeq
IceDelegateM::TradeGateway::TradeApiSession::NewOrders(const ::TradeGateway::OrderSeq& ords, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__NewOrders_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(ords.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeOrderSeq(__os, &ords[0], &ords[0] + ords.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::StringSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        __is->read(__ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::cancelOrders(const ::Ice::StringSeq& orderId, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__cancelOrders_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        if(orderId.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&orderId[0], &orderId[0] + orderId.size());
        }
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.is()->skipEmptyEncaps();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::TradeGateway::OrderReportSeq
IceDelegateM::TradeGateway::TradeApiSession::QryOrder(const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__QryOrder_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(ordid);
        __os->write(positionString);
        __os->write(maxReturn);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::TradeGateway::OrderReportSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::TradeGateway::__readOrderReportSeq(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::TradeGateway::ExecutionReportSeq
IceDelegateM::TradeGateway::TradeApiSession::QryTrade(const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__QryTrade_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(ordid);
        __os->write(positionString);
        __os->write(maxReturn);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::TradeGateway::ExecutionReportSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::TradeGateway::__readExecutionReportSeq(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::TradeGateway::AssetInfoSeq
IceDelegateM::TradeGateway::TradeApiSession::QryAsset(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__QryAsset_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::TradeGateway::AssetInfoSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::TradeGateway::__readAssetInfoSeq(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::TradeGateway::PositionInfoSeq
IceDelegateM::TradeGateway::TradeApiSession::QryPosition(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__QryPosition_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::TradeGateway::PositionInfoSeq __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::TradeGateway::__readPositionInfoSeq(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::TradeGateway::TradeApiSession::destroy(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__TradeApiSession__destroy_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::TradeGateway::TradeApiSessionPrx
IceDelegateM::TradeGateway::SessionManager::createSession(const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__SessionManager__createSession_name, ::Ice::Normal, __context);
    bool __ok = __og.invoke();
    ::TradeGateway::TradeApiSessionPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::TradeGateway::OperationFailedException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.is();
        __is->startReadEncaps();
        ::TradeGateway::__read(__is, __ret);
        __is->endReadEncaps();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::TradeGateway::SessionManager::freeSession(const ::TradeGateway::TradeApiSessionPrx& oldSession, const ::Ice::Context* __context)
{
    ::IceInternal::Outgoing __og(__handler.get(), __TradeGateway__SessionManager__freeSession_name, ::Ice::Normal, __context);
    try
    {
        ::IceInternal::BasicStream* __os = __og.os();
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(oldSession.get())));
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(!__og.is()->b.empty())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.is()->skipEmptyEncaps();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateD::TradeGateway::SessionReceiver::onExecutionReport(const ::TradeGateway::ExecutionReportSeq& report, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::TradeGateway::ExecutionReportSeq& report, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_report(report)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::SessionReceiver* servant = dynamic_cast< ::TradeGateway::SessionReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->onExecutionReport(_m_report, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::TradeGateway::ExecutionReportSeq& _m_report;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__SessionReceiver__onExecutionReport_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(report, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::TradeGateway::SessionReceiver::onMessage(const ::TradeGateway::MessageInfoSeq& msg, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::TradeGateway::MessageInfoSeq& msg, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_msg(msg)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::SessionReceiver* servant = dynamic_cast< ::TradeGateway::SessionReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->onMessage(_m_msg, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::TradeGateway::MessageInfoSeq& _m_msg;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__SessionReceiver__onMessage_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(msg, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::TradeGateway::TradeApiSession::registerCallback(const ::TradeGateway::SessionReceiverPrx& proxy, ::TradeGateway::ResumeType type, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::TradeGateway::SessionReceiverPrx& proxy, ::TradeGateway::ResumeType type, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_proxy(proxy),
            _m_type(type)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->registerCallback(_m_proxy, _m_type, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::TradeGateway::SessionReceiverPrx& _m_proxy;
        ::TradeGateway::ResumeType _m_type;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__registerCallback_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(proxy, type, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::TradeGateway::TradeApiSession::unregisterCallback(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->unregisterCallback(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__unregisterCallback_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::TradeGateway::TradeApiSession::startSession(const ::std::string& frontAddress, const ::Ice::PropertyDict& params, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& frontAddress, const ::Ice::PropertyDict& params, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_frontAddress(frontAddress),
            _m_params(params)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->startSession(_m_frontAddress, _m_params, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_frontAddress;
        const ::Ice::PropertyDict& _m_params;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__startSession_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(frontAddress, params, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::TradeGateway::TradeApiSession::stopSession(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->stopSession(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__stopSession_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::TradeGateway::TradeApiSession::login(const ::std::string& accName, const ::std::string& accPassword, const ::Ice::PropertyDict& params, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& accName, const ::std::string& accPassword, const ::Ice::PropertyDict& params, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_accName(accName),
            _m_accPassword(accPassword),
            _m_params(params)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->login(_m_accName, _m_accPassword, _m_params, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_accName;
        const ::std::string& _m_accPassword;
        const ::Ice::PropertyDict& _m_params;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__login_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(accName, accPassword, params, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::TradeGateway::TradeApiSession::logout(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->logout(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__logout_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::TradeGateway::TradeApiSession::NewOrderSingle(const ::TradeGateway::Order& ord, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::TradeGateway::Order& ord, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_ord(ord)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->NewOrderSingle(_m_ord, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::std::string& _result;
        const ::TradeGateway::Order& _m_ord;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__NewOrderSingle_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, ord, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::TradeGateway::TradeApiSession::cancelOrderSingle(const ::std::string& orderId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& orderId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_orderId(orderId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->cancelOrderSingle(_m_orderId, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_orderId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__cancelOrderSingle_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(orderId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::StringSeq
IceDelegateD::TradeGateway::TradeApiSession::NewOrders(const ::TradeGateway::OrderSeq& ords, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::StringSeq& __result, const ::TradeGateway::OrderSeq& ords, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_ords(ords)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->NewOrders(_m_ords, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::StringSeq& _result;
        const ::TradeGateway::OrderSeq& _m_ords;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__NewOrders_name, ::Ice::Normal, __context);
    ::Ice::StringSeq __result;
    try
    {
        _DirectI __direct(__result, ords, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::TradeGateway::TradeApiSession::cancelOrders(const ::Ice::StringSeq& orderId, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::StringSeq& orderId, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_orderId(orderId)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->cancelOrders(_m_orderId, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::Ice::StringSeq& _m_orderId;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__cancelOrders_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(orderId, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::TradeGateway::OrderReportSeq
IceDelegateD::TradeGateway::TradeApiSession::QryOrder(const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::TradeGateway::OrderReportSeq& __result, const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_ordid(ordid),
            _m_positionString(positionString),
            _m_maxReturn(maxReturn)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->QryOrder(_m_ordid, _m_positionString, _m_maxReturn, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::TradeGateway::OrderReportSeq& _result;
        const ::std::string& _m_ordid;
        const ::std::string& _m_positionString;
        ::Ice::Int _m_maxReturn;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__QryOrder_name, ::Ice::Normal, __context);
    ::TradeGateway::OrderReportSeq __result;
    try
    {
        _DirectI __direct(__result, ordid, positionString, maxReturn, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::TradeGateway::ExecutionReportSeq
IceDelegateD::TradeGateway::TradeApiSession::QryTrade(const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::TradeGateway::ExecutionReportSeq& __result, const ::std::string& ordid, const ::std::string& positionString, ::Ice::Int maxReturn, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_ordid(ordid),
            _m_positionString(positionString),
            _m_maxReturn(maxReturn)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->QryTrade(_m_ordid, _m_positionString, _m_maxReturn, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::TradeGateway::ExecutionReportSeq& _result;
        const ::std::string& _m_ordid;
        const ::std::string& _m_positionString;
        ::Ice::Int _m_maxReturn;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__QryTrade_name, ::Ice::Normal, __context);
    ::TradeGateway::ExecutionReportSeq __result;
    try
    {
        _DirectI __direct(__result, ordid, positionString, maxReturn, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::TradeGateway::AssetInfoSeq
IceDelegateD::TradeGateway::TradeApiSession::QryAsset(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::TradeGateway::AssetInfoSeq& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->QryAsset(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::TradeGateway::AssetInfoSeq& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__QryAsset_name, ::Ice::Normal, __context);
    ::TradeGateway::AssetInfoSeq __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::TradeGateway::PositionInfoSeq
IceDelegateD::TradeGateway::TradeApiSession::QryPosition(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::TradeGateway::PositionInfoSeq& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->QryPosition(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::TradeGateway::PositionInfoSeq& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__QryPosition_name, ::Ice::Normal, __context);
    ::TradeGateway::PositionInfoSeq __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::TradeGateway::TradeApiSession::destroy(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::TradeApiSession* servant = dynamic_cast< ::TradeGateway::TradeApiSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->destroy(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__TradeApiSession__destroy_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::TradeGateway::TradeApiSessionPrx
IceDelegateD::TradeGateway::SessionManager::createSession(const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::TradeGateway::TradeApiSessionPrx& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::SessionManager* servant = dynamic_cast< ::TradeGateway::SessionManager*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->createSession(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::TradeGateway::TradeApiSessionPrx& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__SessionManager__createSession_name, ::Ice::Normal, __context);
    ::TradeGateway::TradeApiSessionPrx __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::TradeGateway::OperationFailedException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::TradeGateway::SessionManager::freeSession(const ::TradeGateway::TradeApiSessionPrx& oldSession, const ::Ice::Context* __context)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::TradeGateway::TradeApiSessionPrx& oldSession, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_oldSession(oldSession)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::TradeGateway::SessionManager* servant = dynamic_cast< ::TradeGateway::SessionManager*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->freeSession(_m_oldSession, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::TradeGateway::TradeApiSessionPrx& _m_oldSession;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __TradeGateway__SessionManager__freeSession_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(oldSession, __current);
        try
        {
            __direct.servant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::ObjectPtr
TradeGateway::SessionReceiver::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __TradeGateway__SessionReceiver_ids[2] =
{
    "::Ice::Object",
    "::TradeGateway::SessionReceiver"
};

bool
TradeGateway::SessionReceiver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__TradeGateway__SessionReceiver_ids, __TradeGateway__SessionReceiver_ids + 2, _s);
}

::std::vector< ::std::string>
TradeGateway::SessionReceiver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__TradeGateway__SessionReceiver_ids[0], &__TradeGateway__SessionReceiver_ids[2]);
}

const ::std::string&
TradeGateway::SessionReceiver::ice_id(const ::Ice::Current&) const
{
    return __TradeGateway__SessionReceiver_ids[1];
}

const ::std::string&
TradeGateway::SessionReceiver::ice_staticId()
{
    return __TradeGateway__SessionReceiver_ids[1];
}

::Ice::DispatchStatus
TradeGateway::SessionReceiver::___onExecutionReport(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::TradeGateway::ExecutionReportSeq report;
    ::TradeGateway::__readExecutionReportSeq(__is, report);
    __is->endReadEncaps();
    onExecutionReport(report, __current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::SessionReceiver::___onMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::TradeGateway::MessageInfoSeq msg;
    ::TradeGateway::__readMessageInfoSeq(__is, msg);
    __is->endReadEncaps();
    onMessage(msg, __current);
    return ::Ice::DispatchOK;
}

static ::std::string __TradeGateway__SessionReceiver_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "onExecutionReport",
    "onMessage"
};

::Ice::DispatchStatus
TradeGateway::SessionReceiver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__TradeGateway__SessionReceiver_all, __TradeGateway__SessionReceiver_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __TradeGateway__SessionReceiver_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___onExecutionReport(in, current);
        }
        case 5:
        {
            return ___onMessage(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
TradeGateway::SessionReceiver::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
TradeGateway::SessionReceiver::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
TradeGateway::SessionReceiver::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type TradeGateway::SessionReceiver was not generated with stream support";
    throw ex;
}

void
TradeGateway::SessionReceiver::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type TradeGateway::SessionReceiver was not generated with stream support";
    throw ex;
}
#endif

void 
TradeGateway::__patch__SessionReceiverPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::TradeGateway::SessionReceiverPtr* p = static_cast< ::TradeGateway::SessionReceiverPtr*>(__addr);
    assert(p);
    *p = ::TradeGateway::SessionReceiverPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::TradeGateway::SessionReceiver::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
TradeGateway::TradeApiSession::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __TradeGateway__TradeApiSession_ids[2] =
{
    "::Ice::Object",
    "::TradeGateway::TradeApiSession"
};

bool
TradeGateway::TradeApiSession::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__TradeGateway__TradeApiSession_ids, __TradeGateway__TradeApiSession_ids + 2, _s);
}

::std::vector< ::std::string>
TradeGateway::TradeApiSession::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__TradeGateway__TradeApiSession_ids[0], &__TradeGateway__TradeApiSession_ids[2]);
}

const ::std::string&
TradeGateway::TradeApiSession::ice_id(const ::Ice::Current&) const
{
    return __TradeGateway__TradeApiSession_ids[1];
}

const ::std::string&
TradeGateway::TradeApiSession::ice_staticId()
{
    return __TradeGateway__TradeApiSession_ids[1];
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___registerCallback(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::TradeGateway::SessionReceiverPrx proxy;
    ::TradeGateway::ResumeType type;
    ::TradeGateway::__read(__is, proxy);
    ::TradeGateway::__read(__is, type);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        registerCallback(proxy, type, __current);
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___unregisterCallback(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    unregisterCallback(__current);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___startSession(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string frontAddress;
    ::Ice::PropertyDict params;
    __is->read(frontAddress);
    ::Ice::__readPropertyDict(__is, params);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        startSession(frontAddress, params, __current);
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___stopSession(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        stopSession(__current);
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___login(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string accName;
    ::std::string accPassword;
    ::Ice::PropertyDict params;
    __is->read(accName);
    __is->read(accPassword);
    ::Ice::__readPropertyDict(__is, params);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        login(accName, accPassword, params, __current);
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___logout(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        logout(__current);
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___NewOrderSingle(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::TradeGateway::Order ord;
    ord.__read(__is);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::std::string __ret = NewOrderSingle(ord, __current);
        __os->write(__ret);
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___cancelOrderSingle(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string orderId;
    __is->read(orderId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        cancelOrderSingle(orderId, __current);
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___NewOrders(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::TradeGateway::OrderSeq ords;
    ::TradeGateway::__readOrderSeq(__is, ords);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::Ice::StringSeq __ret = NewOrders(ords, __current);
        if(__ret.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            __os->write(&__ret[0], &__ret[0] + __ret.size());
        }
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___cancelOrders(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::Ice::StringSeq orderId;
    __is->read(orderId);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        cancelOrders(orderId, __current);
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___QryOrder(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string ordid;
    ::std::string positionString;
    ::Ice::Int maxReturn;
    __is->read(ordid);
    __is->read(positionString);
    __is->read(maxReturn);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::TradeGateway::OrderReportSeq __ret = QryOrder(ordid, positionString, maxReturn, __current);
        if(__ret.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeOrderReportSeq(__os, &__ret[0], &__ret[0] + __ret.size());
        }
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___QryTrade(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::std::string ordid;
    ::std::string positionString;
    ::Ice::Int maxReturn;
    __is->read(ordid);
    __is->read(positionString);
    __is->read(maxReturn);
    __is->endReadEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::TradeGateway::ExecutionReportSeq __ret = QryTrade(ordid, positionString, maxReturn, __current);
        if(__ret.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeExecutionReportSeq(__os, &__ret[0], &__ret[0] + __ret.size());
        }
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___QryAsset(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::TradeGateway::AssetInfoSeq __ret = QryAsset(__current);
        if(__ret.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writeAssetInfoSeq(__os, &__ret[0], &__ret[0] + __ret.size());
        }
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___QryPosition(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::TradeGateway::PositionInfoSeq __ret = QryPosition(__current);
        if(__ret.size() == 0)
        {
            __os->writeSize(0);
        }
        else
        {
            ::TradeGateway::__writePositionInfoSeq(__os, &__ret[0], &__ret[0] + __ret.size());
        }
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::TradeApiSession::___destroy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    destroy(__current);
    return ::Ice::DispatchOK;
}

static ::std::string __TradeGateway__TradeApiSession_all[] =
{
    "NewOrderSingle",
    "NewOrders",
    "QryAsset",
    "QryOrder",
    "QryPosition",
    "QryTrade",
    "cancelOrderSingle",
    "cancelOrders",
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "login",
    "logout",
    "registerCallback",
    "startSession",
    "stopSession",
    "unregisterCallback"
};

::Ice::DispatchStatus
TradeGateway::TradeApiSession::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__TradeGateway__TradeApiSession_all, __TradeGateway__TradeApiSession_all + 19, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __TradeGateway__TradeApiSession_all)
    {
        case 0:
        {
            return ___NewOrderSingle(in, current);
        }
        case 1:
        {
            return ___NewOrders(in, current);
        }
        case 2:
        {
            return ___QryAsset(in, current);
        }
        case 3:
        {
            return ___QryOrder(in, current);
        }
        case 4:
        {
            return ___QryPosition(in, current);
        }
        case 5:
        {
            return ___QryTrade(in, current);
        }
        case 6:
        {
            return ___cancelOrderSingle(in, current);
        }
        case 7:
        {
            return ___cancelOrders(in, current);
        }
        case 8:
        {
            return ___destroy(in, current);
        }
        case 9:
        {
            return ___ice_id(in, current);
        }
        case 10:
        {
            return ___ice_ids(in, current);
        }
        case 11:
        {
            return ___ice_isA(in, current);
        }
        case 12:
        {
            return ___ice_ping(in, current);
        }
        case 13:
        {
            return ___login(in, current);
        }
        case 14:
        {
            return ___logout(in, current);
        }
        case 15:
        {
            return ___registerCallback(in, current);
        }
        case 16:
        {
            return ___startSession(in, current);
        }
        case 17:
        {
            return ___stopSession(in, current);
        }
        case 18:
        {
            return ___unregisterCallback(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
TradeGateway::TradeApiSession::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
TradeGateway::TradeApiSession::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
TradeGateway::TradeApiSession::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type TradeGateway::TradeApiSession was not generated with stream support";
    throw ex;
}

void
TradeGateway::TradeApiSession::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type TradeGateway::TradeApiSession was not generated with stream support";
    throw ex;
}
#endif

void 
TradeGateway::__patch__TradeApiSessionPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::TradeGateway::TradeApiSessionPtr* p = static_cast< ::TradeGateway::TradeApiSessionPtr*>(__addr);
    assert(p);
    *p = ::TradeGateway::TradeApiSessionPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::TradeGateway::TradeApiSession::ice_staticId(), v->ice_id());
    }
}

::Ice::ObjectPtr
TradeGateway::SessionManager::ice_clone() const
{
    throw ::Ice::CloneNotImplementedException(__FILE__, __LINE__);
    return 0; // to avoid a warning with some compilers
}

static const ::std::string __TradeGateway__SessionManager_ids[2] =
{
    "::Ice::Object",
    "::TradeGateway::SessionManager"
};

bool
TradeGateway::SessionManager::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__TradeGateway__SessionManager_ids, __TradeGateway__SessionManager_ids + 2, _s);
}

::std::vector< ::std::string>
TradeGateway::SessionManager::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__TradeGateway__SessionManager_ids[0], &__TradeGateway__SessionManager_ids[2]);
}

const ::std::string&
TradeGateway::SessionManager::ice_id(const ::Ice::Current&) const
{
    return __TradeGateway__SessionManager_ids[1];
}

const ::std::string&
TradeGateway::SessionManager::ice_staticId()
{
    return __TradeGateway__SessionManager_ids[1];
}

::Ice::DispatchStatus
TradeGateway::SessionManager::___createSession(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.is()->skipEmptyEncaps();
    ::IceInternal::BasicStream* __os = __inS.os();
    try
    {
        ::TradeGateway::TradeApiSessionPrx __ret = createSession(__current);
        __os->write(::Ice::ObjectPrx(::IceInternal::upCast(__ret.get())));
    }
    catch(const ::TradeGateway::OperationFailedException& __ex)
    {
        __os->write(__ex);
        return ::Ice::DispatchUserException;
    }
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
TradeGateway::SessionManager::___freeSession(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.is();
    __is->startReadEncaps();
    ::TradeGateway::TradeApiSessionPrx oldSession;
    ::TradeGateway::__read(__is, oldSession);
    __is->endReadEncaps();
    freeSession(oldSession, __current);
    return ::Ice::DispatchOK;
}

static ::std::string __TradeGateway__SessionManager_all[] =
{
    "createSession",
    "freeSession",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

::Ice::DispatchStatus
TradeGateway::SessionManager::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< ::std::string*, ::std::string*> r = ::std::equal_range(__TradeGateway__SessionManager_all, __TradeGateway__SessionManager_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __TradeGateway__SessionManager_all)
    {
        case 0:
        {
            return ___createSession(in, current);
        }
        case 1:
        {
            return ___freeSession(in, current);
        }
        case 2:
        {
            return ___ice_id(in, current);
        }
        case 3:
        {
            return ___ice_ids(in, current);
        }
        case 4:
        {
            return ___ice_isA(in, current);
        }
        case 5:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
TradeGateway::SessionManager::__write(::IceInternal::BasicStream* __os) const
{
    __os->writeTypeId(ice_staticId());
    __os->startWriteSlice();
    __os->endWriteSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__write(__os);
#else
    ::Ice::Object::__write(__os);
#endif
}

void
TradeGateway::SessionManager::__read(::IceInternal::BasicStream* __is, bool __rid)
{
    if(__rid)
    {
        ::std::string myId;
        __is->readTypeId(myId);
    }
    __is->startReadSlice();
    __is->endReadSlice();
#if defined(_MSC_VER) && (_MSC_VER < 1300) // VC++ 6 compiler bug
    Object::__read(__is, true);
#else
    ::Ice::Object::__read(__is, true);
#endif
}

// COMPILERFIX: Stream API is not supported with VC++ 6
#if !defined(_MSC_VER) || (_MSC_VER >= 1300)
void
TradeGateway::SessionManager::__write(const ::Ice::OutputStreamPtr&) const
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type TradeGateway::SessionManager was not generated with stream support";
    throw ex;
}

void
TradeGateway::SessionManager::__read(const ::Ice::InputStreamPtr&, bool)
{
    Ice::MarshalException ex(__FILE__, __LINE__);
    ex.reason = "type TradeGateway::SessionManager was not generated with stream support";
    throw ex;
}
#endif

void 
TradeGateway::__patch__SessionManagerPtr(void* __addr, ::Ice::ObjectPtr& v)
{
    ::TradeGateway::SessionManagerPtr* p = static_cast< ::TradeGateway::SessionManagerPtr*>(__addr);
    assert(p);
    *p = ::TradeGateway::SessionManagerPtr::dynamicCast(v);
    if(v && !*p)
    {
        IceInternal::Ex::throwUOE(::TradeGateway::SessionManager::ice_staticId(), v->ice_id());
    }
}
